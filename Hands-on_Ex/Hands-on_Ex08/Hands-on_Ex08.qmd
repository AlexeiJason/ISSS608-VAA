---
title: "Hands-on Exercise 8: Modelling, Visualising and Analysing Network Data with R"
author: "Alexei Jason"
date: "March 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

## Overview

In this hands-on exercise, you will learn how to model, analyse and visualise network data using R.

By the end of this hands-on exercise, you will be able to:

-   create graph object data frames, manipulate them using appropriate functions of *dplyr*, *lubridate*, and *tidygraph*,
-   build network graph visualisation using appropriate functions of *ggraph*,
-   compute network geometrics using *tidygraph*,
-   build advanced graph visualisation by incorporating the network geometrics, and
-   build interactive network visualisation using *visNetwork* package.

## Getting Started

### Installing and launching R packages

In this hands-on exercise, four network data modelling and visualisation packages will be installed and launched. They are igraph, tidygraph, ggraph and visNetwork. Beside these four packages, tidyverse and [lubridate](https://lubridate.tidyverse.org/), an R package specially designed to handle and wrangling time data will be installed and launched too.

The code chunk:

```{r}
pacman::p_load(igraph, tidygraph, ggraph, 
               visNetwork, lubridate, clock,
               tidyverse, graphlayouts)
```

## The Data

The data sets used in this hands-on exercise is from an oil exploration and extraction company. There are two data sets. One contains the nodes data and the other contains the edges (also know as link) data.

### The edges data

-   *GAStech-email_edges.csv* which consists of two weeks of 9063 emails correspondances between 55 employees.

![](images/image2 (2).jpg)

### The nodes data

-   *GAStech_email_nodes.csv* which consist of the names, department and title of the 55 employees.

![](images/image1 (2).jpg)

### Importing network data from files

In this step, you will import GAStech_email_node.csv and GAStech_email_edges-v2.csv into RStudio environment by using `read_csv()` of **readr** package.

```{r}
GAStech_nodes <- read_csv("data/GAStech_email_node.csv")
GAStech_edges <- read_csv("data/GAStech_email_edge-v2.csv")
```

### Reviewing the imported data

Next, we will examine the structure of the data frame using *glimpse()* of **dplyr**.

```{r}
glimpse(GAStech_edges)
```

::: callout-warning
The output report of GAStech_edges above reveals that the *SentDate* is treated as "Character" data type instead of *date* data type. This is an error! Before we continue, it is important for us to change the data type of *SentDate* field back to "Date"" data type.
:::

### Wrangling time

The code chunk below will be used to perform the changes.

```{r} GAStech_edges <- GAStech_edges %>%   mutate(SendDate = dmy(SentDate)) %>%   mutate(Weekday = wday(SentDate,                         label = TRUE,                         abbr = FALSE))}
```

::: callout-tip
## Things to learn from the code chunk above

-   both *dmy()* and *wday()* are functions of **lubridate** package. [lubridate](cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html) is an R package that makes it easier to work with dates and times.
-   *dmy()* transforms the SentDate to Date data type.
-   *wday()* returns the day of the week as a decimal number or an ordered factor if label is TRUE. The argument abbr is FALSE keep the daya spells in full, i.e. Monday. The function will create a new column in the data.frame i.e. Weekday and the output of *wday()* will save in this newly created field.
-   the values in the *Weekday* field are in ordinal scale.
:::

### Reviewing the revised date fields

Table below shows the data structure of the reformatted *GAStech_edges* data frame

```{r} #| echo: false glimpse(GAStech_edges)}
```

### Wrangling attributes

A close examination of *GAStech_edges* data.frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.

In view of this, we will aggregate the individual by date, senders, receivers, main subject and day of the week.

The code chunk:

```{r} GAStech_edges_aggregated <- GAStech_edges %>%   filter(MainSubject == "Work related") %>%   group_by(source, target, Weekday) %>%     summarise(Weight = n()) %>%   filter(source!=target) %>%   filter(Weight > 1) %>%   ungroup()}
```

::: callout-tip
## Things to learn from the code chunk above:

-   four functions from **dplyr** package are used. They are: *filter()*, *group()*, *summarise()*, and *ungroup()*.
-   The output data.frame is called **GAStech_edges_aggregated**.
-   A new field called *Weight* has been added in GAStech_edges_aggregated.
:::

### Reviewing the revised edges file

Table below shows the data structure of the reformatted *GAStech_edges* data frame

```{r} #| echo: false glimpse(GAStech_edges_aggregated)}
```

## Creating network objects using **tidygraph**

In this section, you will learn how to create a graph data model by using **tidygraph** package. It provides a tidy API for graph/network manipulation. While network data itself is not tidy, it can be envisioned as two tidy tables, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides dplyr verbs for manipulating them. Furthermore it provides access to a lot of graph algorithms with return values that facilitate their use in a tidy workflow.

Before getting started, you are advised to read these two articles:

-   [Introducing tidygraph](https://www.data-imaginist.com/2017/introducing-tidygraph/)
-   [tidygraph 1.1 - A tidy hope](https://www.data-imaginist.com/2018/tidygraph-1-1-a-tidy-hope/)

### The **tbl_graph** object

Two functions of **tidygraph** package can be used to create network objects, they are:

-   [`tbl_graph()`](https://tidygraph.data-imaginist.com/reference/tbl_graph.html) creates a **tbl_graph** network object from nodes and edges data.

-   [`as_tbl_graph()`](https://tidygraph.data-imaginist.com/reference/tbl_graph.html) converts network data and objects to a **tbl_graph** network. Below are network data and objects supported by `as_tbl_graph()`

    -   a node data.frame and an edge data.frame,
    -   data.frame, list, matrix from base,
    -   igraph from igraph,
    -   network from network,
    -   dendrogram and hclust from stats,
    -   Node from data.tree,
    -   phylo and evonet from ape, and
    -   graphNEL, graphAM, graphBAM from graph (in Bioconductor).

### The **dplyr** verbs in **tidygraph**

-   *activate()* verb from **tidygraph** serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to **tbl_graph** object are applied to the active tibble.

![](images/image3.jpg)

-   In the above the *.N()* function is used to gain access to the node data while manipulating the edge data. Similarly *.E()* will give you the edge data and *.G()* will give you the **tbl_graph** object itself.

### Using `tbl_graph()` to build tidygraph data model.

In this section, you will use `tbl_graph()` of **tinygraph** package to build an tidygraph's network graph data.frame.

Before typing the codes, you are recommended to review to reference guide of [`tbl_graph()`](https://tidygraph.data-imaginist.com/reference/tbl_graph.html)

```{r} GAStech_graph <- tbl_graph(nodes = GAStech_nodes,                            edges = GAStech_edges_aggregated,                             directed = TRUE)}
```

### Reviewing the output tidygraph's graph object

```{r} GAStech_graph}
```

### Reviewing the output tidygraph's graph object

-   The output above reveals that *GAStech_graph* is a tbl_graph object with 54 nodes and 4541 edges.
-   The command also prints the first six rows of "Node Data" and the first three of "Edge Data".
-   It states that the Node Data is **active**. The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time.

### Changing the active object

The nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the *activate()* function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest "weight" first, we could use *activate()* and then *arrange()*.

For example,

```{r} #| eval: false GAStech_graph %>%   activate(edges) %>%   arrange(desc(Weight))}
```

Visit the reference guide of [*activate()*](https://tidygraph.data-imaginist.com/reference/activate.html) to find out more about the function.

## 
